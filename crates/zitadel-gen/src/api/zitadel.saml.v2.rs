// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SamlRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub creation_date: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, tag="3")]
    pub issuer: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub assertion_consumer_service: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub relay_state: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub binding: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorizationError {
    #[prost(enumeration="ErrorReason", tag="1")]
    pub error: i32,
    #[prost(string, optional, tag="2")]
    pub error_description: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorReason {
    Unspecified = 0,
    VersionMissmatch = 1,
    AuthNFailed = 2,
    InvalidAttrNameOrValue = 3,
    InvalidNameidPolicy = 4,
    RequestDenied = 5,
    RequestUnsupported = 6,
    UnsupportedBinding = 7,
}
impl ErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ErrorReason::Unspecified => "ERROR_REASON_UNSPECIFIED",
            ErrorReason::VersionMissmatch => "ERROR_REASON_VERSION_MISSMATCH",
            ErrorReason::AuthNFailed => "ERROR_REASON_AUTH_N_FAILED",
            ErrorReason::InvalidAttrNameOrValue => "ERROR_REASON_INVALID_ATTR_NAME_OR_VALUE",
            ErrorReason::InvalidNameidPolicy => "ERROR_REASON_INVALID_NAMEID_POLICY",
            ErrorReason::RequestDenied => "ERROR_REASON_REQUEST_DENIED",
            ErrorReason::RequestUnsupported => "ERROR_REASON_REQUEST_UNSUPPORTED",
            ErrorReason::UnsupportedBinding => "ERROR_REASON_UNSUPPORTED_BINDING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_REASON_VERSION_MISSMATCH" => Some(Self::VersionMissmatch),
            "ERROR_REASON_AUTH_N_FAILED" => Some(Self::AuthNFailed),
            "ERROR_REASON_INVALID_ATTR_NAME_OR_VALUE" => Some(Self::InvalidAttrNameOrValue),
            "ERROR_REASON_INVALID_NAMEID_POLICY" => Some(Self::InvalidNameidPolicy),
            "ERROR_REASON_REQUEST_DENIED" => Some(Self::RequestDenied),
            "ERROR_REASON_REQUEST_UNSUPPORTED" => Some(Self::RequestUnsupported),
            "ERROR_REASON_UNSUPPORTED_BINDING" => Some(Self::UnsupportedBinding),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSamlRequestRequest {
    /// ID of the SAML Request, as obtained from the redirect URL.
    #[prost(string, tag="1")]
    pub saml_request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSamlRequestResponse {
    #[prost(message, optional, tag="1")]
    pub saml_request: ::core::option::Option<SamlRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResponseRequest {
    /// ID of the SAML Request.
    #[prost(string, tag="1")]
    pub saml_request_id: ::prost::alloc::string::String,
    #[prost(oneof="create_response_request::ResponseKind", tags="2, 3")]
    pub response_kind: ::core::option::Option<create_response_request::ResponseKind>,
}
/// Nested message and enum types in `CreateResponseRequest`.
pub mod create_response_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseKind {
        #[prost(message, tag="2")]
        Session(super::Session),
        /// Set this field when the authorization flow failed. It creates a response depending on the SP, with the error details set.
        #[prost(message, tag="3")]
        Error(super::AuthorizationError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    /// ID of the session, used to login the user. Connects the session to the SAML Request.
    #[prost(string, tag="1")]
    pub session_id: ::prost::alloc::string::String,
    /// Token to verify the session is valid.
    #[prost(string, tag="2")]
    pub session_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResponseResponse {
    #[prost(message, optional, tag="1")]
    pub details: ::core::option::Option<super::super::object::v2::Details>,
    /// URL including the Assertion Consumer Service where the user should be redirected or has to call per POST, depending on the binding. Contains details for the application to obtain the response on success, or error details on failure. Note that this field must be treated as credentials, as the contained SAMLResponse or code can be used on behalve of the user.
    #[prost(string, tag="2")]
    pub url: ::prost::alloc::string::String,
    /// Binding is defined through the request, what the IDP is able to use and what bindings are available for the SP.
    #[prost(oneof="create_response_response::Binding", tags="3, 4")]
    pub binding: ::core::option::Option<create_response_response::Binding>,
}
/// Nested message and enum types in `CreateResponseResponse`.
pub mod create_response_response {
    /// Binding is defined through the request, what the IDP is able to use and what bindings are available for the SP.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Binding {
        /// Set if the binding is Redirect-Binding, where the user can directly be redirected to the application, using a \"302 FOUND\" status to the URL.
        #[prost(message, tag="3")]
        Redirect(super::RedirectResponse),
        /// Set if the binding is POST-Binding, where the application expects to be called per HTTP POST with the SAMLResponse and RelayState in the form body.
        #[prost(message, tag="4")]
        Post(super::PostResponse),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedirectResponse {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostResponse {
    #[prost(string, tag="1")]
    pub relay_state: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub saml_response: ::prost::alloc::string::String,
}
include!("zitadel.saml.v2.tonic.rs");
// @@protoc_insertion_point(module)