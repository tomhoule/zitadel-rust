// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserSchema {
    /// Details provide some base information (such as the last change date) of the schema.
    #[prost(message, optional, tag="1")]
    pub details: ::core::option::Option<super::super::object::v3alpha::Details>,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<UserSchema>,
    /// Current state of the schema.
    #[prost(enumeration="State", tag="3")]
    pub state: i32,
    /// Revision is a read only version of the schema, each update of the `schema`-field increases the revision.
    #[prost(uint32, tag="4")]
    pub revision: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSchema {
    /// Type is a human readable word describing the schema.
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    /// Defines the possible types of authenticators.
    #[prost(enumeration="AuthenticatorType", repeated, packed="false", tag="3")]
    pub possible_authenticators: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof="user_schema::DataType", tags="2")]
    pub data_type: ::core::option::Option<user_schema::DataType>,
}
/// Nested message and enum types in `UserSchema`.
pub mod user_schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataType {
        /// JSON schema representation defining the user.
        #[prost(message, tag="2")]
        Schema(::pbjson_types::Struct),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchUserSchema {
    /// Type is a human readable word describing the schema.
    #[prost(string, optional, tag="2")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// Defines the possible types of authenticators.
    ///
    /// Removal of an authenticator does not remove the authenticator on a user.
    #[prost(enumeration="AuthenticatorType", repeated, packed="false", tag="4")]
    pub possible_authenticators: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof="patch_user_schema::DataType", tags="3")]
    pub data_type: ::core::option::Option<patch_user_schema::DataType>,
}
/// Nested message and enum types in `PatchUserSchema`.
pub mod patch_user_schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataType {
        /// JSON schema representation defining the user.
        #[prost(message, tag="3")]
        Schema(::pbjson_types::Struct),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchFilter {
    #[prost(oneof="search_filter::Filter", tags="1, 2, 3, 5, 6, 7")]
    pub filter: ::core::option::Option<search_filter::Filter>,
}
/// Nested message and enum types in `SearchFilter`.
pub mod search_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        /// Union the results of each sub filter ('OR').
        #[prost(message, tag="1")]
        OrFilter(super::OrFilter),
        /// Limit the result to match all sub queries ('AND').
        /// Note that if you specify multiple queries, they will be implicitly used as andQueries.
        /// Use the andFilter in combination with orFilter and notFilter.
        #[prost(message, tag="2")]
        AndFilter(super::AndFilter),
        /// Exclude / Negate the result of the sub filter ('NOT').
        #[prost(message, tag="3")]
        NotFilter(::prost::alloc::boxed::Box<super::NotFilter>),
        /// Limit the result to a specific schema type.
        #[prost(message, tag="5")]
        TypeFilter(super::TypeFilter),
        /// Limit the result to a specific state of the schema.
        #[prost(message, tag="6")]
        StateFilter(super::StateFilter),
        /// Limit the result to a specific schema ID.
        #[prost(message, tag="7")]
        IdFilter(super::IdFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrFilter {
    #[prost(message, repeated, tag="1")]
    pub queries: ::prost::alloc::vec::Vec<SearchFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndFilter {
    #[prost(message, repeated, tag="1")]
    pub queries: ::prost::alloc::vec::Vec<SearchFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotFilter {
    #[prost(message, optional, boxed, tag="1")]
    pub filter: ::core::option::Option<::prost::alloc::boxed::Box<SearchFilter>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdFilter {
    /// Defines the ID of the user schema to filter for.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Defines which text comparison method used for the id filter.
    #[prost(enumeration="super::super::object::v3alpha::TextFilterMethod", tag="2")]
    pub method: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeFilter {
    /// Defines which type to filter for.
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    /// Defines which text comparison method used for the type filter.
    #[prost(enumeration="super::super::object::v3alpha::TextFilterMethod", tag="2")]
    pub method: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StateFilter {
    /// Defines the state to filter for.
    #[prost(enumeration="State", tag="1")]
    pub state: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldName {
    Unspecified = 0,
    Type = 1,
    State = 2,
    Revision = 3,
    ChangeDate = 4,
    CreationDate = 5,
}
impl FieldName {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FieldName::Unspecified => "FIELD_NAME_UNSPECIFIED",
            FieldName::Type => "FIELD_NAME_TYPE",
            FieldName::State => "FIELD_NAME_STATE",
            FieldName::Revision => "FIELD_NAME_REVISION",
            FieldName::ChangeDate => "FIELD_NAME_CHANGE_DATE",
            FieldName::CreationDate => "FIELD_NAME_CREATION_DATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIELD_NAME_UNSPECIFIED" => Some(Self::Unspecified),
            "FIELD_NAME_TYPE" => Some(Self::Type),
            "FIELD_NAME_STATE" => Some(Self::State),
            "FIELD_NAME_REVISION" => Some(Self::Revision),
            "FIELD_NAME_CHANGE_DATE" => Some(Self::ChangeDate),
            "FIELD_NAME_CREATION_DATE" => Some(Self::CreationDate),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    Unspecified = 0,
    Active = 1,
    Inactive = 2,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            State::Unspecified => "STATE_UNSPECIFIED",
            State::Active => "STATE_ACTIVE",
            State::Inactive => "STATE_INACTIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "STATE_ACTIVE" => Some(Self::Active),
            "STATE_INACTIVE" => Some(Self::Inactive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthenticatorType {
    Unspecified = 0,
    Username = 1,
    Password = 2,
    Webauthn = 3,
    Totp = 4,
    OtpEmail = 5,
    OtpSms = 6,
    AuthenticationKey = 7,
    IdentityProvider = 8,
}
impl AuthenticatorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AuthenticatorType::Unspecified => "AUTHENTICATOR_TYPE_UNSPECIFIED",
            AuthenticatorType::Username => "AUTHENTICATOR_TYPE_USERNAME",
            AuthenticatorType::Password => "AUTHENTICATOR_TYPE_PASSWORD",
            AuthenticatorType::Webauthn => "AUTHENTICATOR_TYPE_WEBAUTHN",
            AuthenticatorType::Totp => "AUTHENTICATOR_TYPE_TOTP",
            AuthenticatorType::OtpEmail => "AUTHENTICATOR_TYPE_OTP_EMAIL",
            AuthenticatorType::OtpSms => "AUTHENTICATOR_TYPE_OTP_SMS",
            AuthenticatorType::AuthenticationKey => "AUTHENTICATOR_TYPE_AUTHENTICATION_KEY",
            AuthenticatorType::IdentityProvider => "AUTHENTICATOR_TYPE_IDENTITY_PROVIDER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTHENTICATOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "AUTHENTICATOR_TYPE_USERNAME" => Some(Self::Username),
            "AUTHENTICATOR_TYPE_PASSWORD" => Some(Self::Password),
            "AUTHENTICATOR_TYPE_WEBAUTHN" => Some(Self::Webauthn),
            "AUTHENTICATOR_TYPE_TOTP" => Some(Self::Totp),
            "AUTHENTICATOR_TYPE_OTP_EMAIL" => Some(Self::OtpEmail),
            "AUTHENTICATOR_TYPE_OTP_SMS" => Some(Self::OtpSms),
            "AUTHENTICATOR_TYPE_AUTHENTICATION_KEY" => Some(Self::AuthenticationKey),
            "AUTHENTICATOR_TYPE_IDENTITY_PROVIDER" => Some(Self::IdentityProvider),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchUserSchemasRequest {
    #[prost(message, optional, tag="1")]
    pub instance: ::core::option::Option<super::super::super::object::v3alpha::Instance>,
    /// list limitations and ordering.
    #[prost(message, optional, tag="2")]
    pub query: ::core::option::Option<super::super::object::v3alpha::SearchQuery>,
    /// The field the result is sorted by. The default is the creation date. Beware that if you change this, your result pagination might be inconsistent.
    #[prost(enumeration="FieldName", optional, tag="3")]
    pub sorting_column: ::core::option::Option<i32>,
    /// Define the criteria to filter for.
    #[prost(message, repeated, tag="4")]
    pub filters: ::prost::alloc::vec::Vec<SearchFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchUserSchemasResponse {
    /// Details provides information about the returned result including total amount found.
    #[prost(message, optional, tag="1")]
    pub details: ::core::option::Option<super::super::object::v3alpha::ListDetails>,
    /// States by which field the results are sorted.
    #[prost(enumeration="FieldName", tag="2")]
    pub sorting_column: i32,
    /// The result contains the user schemas, which matched the queries.
    #[prost(message, repeated, tag="3")]
    pub result: ::prost::alloc::vec::Vec<GetUserSchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserSchemaRequest {
    /// unique identifier of the schema.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserSchemaResponse {
    #[prost(message, optional, tag="2")]
    pub user_schema: ::core::option::Option<GetUserSchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserSchemaRequest {
    #[prost(message, optional, tag="1")]
    pub instance: ::core::option::Option<super::super::super::object::v3alpha::Instance>,
    #[prost(message, optional, tag="2")]
    pub user_schema: ::core::option::Option<UserSchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserSchemaResponse {
    /// Details provide some base information (such as the last change date) of the schema.
    #[prost(message, optional, tag="2")]
    pub details: ::core::option::Option<super::super::object::v3alpha::Details>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchUserSchemaRequest {
    #[prost(message, optional, tag="1")]
    pub instance: ::core::option::Option<super::super::super::object::v3alpha::Instance>,
    /// unique identifier of the schema.
    #[prost(string, tag="2")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub user_schema: ::core::option::Option<PatchUserSchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchUserSchemaResponse {
    /// Details provide some base information (such as the last change date) of the schema.
    #[prost(message, optional, tag="1")]
    pub details: ::core::option::Option<super::super::object::v3alpha::Details>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeactivateUserSchemaRequest {
    #[prost(message, optional, tag="2")]
    pub instance: ::core::option::Option<super::super::super::object::v3alpha::Instance>,
    /// unique identifier of the schema.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeactivateUserSchemaResponse {
    /// Details provide some base information (such as the last change date) of the schema.
    #[prost(message, optional, tag="1")]
    pub details: ::core::option::Option<super::super::object::v3alpha::Details>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactivateUserSchemaRequest {
    #[prost(message, optional, tag="2")]
    pub instance: ::core::option::Option<super::super::super::object::v3alpha::Instance>,
    /// unique identifier of the schema.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactivateUserSchemaResponse {
    /// Details provide some base information (such as the last change date) of the schema.
    #[prost(message, optional, tag="1")]
    pub details: ::core::option::Option<super::super::object::v3alpha::Details>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserSchemaRequest {
    #[prost(message, optional, tag="2")]
    pub instance: ::core::option::Option<super::super::super::object::v3alpha::Instance>,
    /// unique identifier of the schema.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserSchemaResponse {
    /// Details provide some base information (such as the last change date) of the schema.
    #[prost(message, optional, tag="1")]
    pub details: ::core::option::Option<super::super::object::v3alpha::Details>,
}
include!("zitadel.resources.userschema.v3alpha.tonic.rs");
// @@protoc_insertion_point(module)